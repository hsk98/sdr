const User = require('../models/User');\nconst pool = require('../config/database');\nconst auditLogger = require('./logger');\nconst crypto = require('crypto');\n\nclass GDPRManager {\n  constructor() {\n    this.dataRetentionPeriod = process.env.DATA_RETENTION_DAYS || 2555; // 7 years default\n  }\n\n  // Export all user data for GDPR compliance\n  async exportUserData(userId, requestedBy) {\n    try {\n      await auditLogger.logSystemEvent('GDPR_DATA_EXPORT_STARTED', {\n        target_user_id: userId,\n        requested_by: requestedBy,\n        timestamp: new Date().toISOString()\n      });\n\n      const userData = {\n        personal_information: await this.getUserPersonalData(userId),\n        assignments: await this.getUserAssignments(userId),\n        activity_logs: await this.getUserActivityLogs(userId),\n        consent_records: await this.getUserConsentRecords(userId),\n        export_metadata: {\n          export_date: new Date().toISOString(),\n          exported_by: requestedBy,\n          format: 'JSON',\n          gdpr_request_id: crypto.randomUUID()\n        }\n      };\n\n      await auditLogger.logSystemEvent('GDPR_DATA_EXPORT_COMPLETED', {\n        target_user_id: userId,\n        requested_by: requestedBy,\n        records_exported: this.countRecords(userData)\n      });\n\n      return userData;\n    } catch (error) {\n      await auditLogger.logError('GDPR_DATA_EXPORT_ERROR', error, {\n        target_user_id: userId,\n        requested_by: requestedBy\n      });\n      throw error;\n    }\n  }\n\n  async getUserPersonalData(userId) {\n    const query = `\n      SELECT \n        id, username, email, first_name, last_name, \n        role, created_at, updated_at, mfa_enabled\n      FROM users \n      WHERE id = ?\n    `;\n    const result = await pool.query(query, [userId]);\n    return result.rows[0] || null;\n  }\n\n  async getUserAssignments(userId) {\n    const query = `\n      SELECT \n        a.id, a.lead_identifier, a.lead_name, a.assigned_at,\n        a.status, a.is_manual, a.manual_reason,\n        c.name as consultant_name\n      FROM assignments a\n      LEFT JOIN consultants c ON a.consultant_id = c.id\n      WHERE a.sdr_id = ?\n      ORDER BY a.assigned_at DESC\n    `;\n    const result = await pool.query(query, [userId]);\n    return result.rows;\n  }\n\n  async getUserActivityLogs(userId) {\n    // This would query the audit log table for user activities\n    // Implementation depends on your audit log structure\n    return [];\n  }\n\n  async getUserConsentRecords(userId) {\n    // Implementation for tracking user consents\n    // This is important for GDPR compliance\n    return {\n      data_processing_consent: {\n        granted: true,\n        date: new Date().toISOString(),\n        version: '1.0'\n      },\n      marketing_consent: {\n        granted: false,\n        date: null,\n        version: null\n      }\n    };\n  }\n\n  // Delete user data while preserving audit trail\n  async deleteUserData(userId, requestedBy, reason) {\n    try {\n      await auditLogger.logSystemEvent('GDPR_DATA_DELETION_STARTED', {\n        target_user_id: userId,\n        requested_by: requestedBy,\n        reason,\n        timestamp: new Date().toISOString()\n      });\n\n      // Get user data before deletion for audit purposes\n      const userData = await this.exportUserData(userId, requestedBy);\n\n      // Anonymize user data instead of hard deletion to preserve referential integrity\n      await this.anonymizeUserData(userId);\n\n      // Mark assignments as anonymized\n      await this.anonymizeUserAssignments(userId);\n\n      await auditLogger.logSystemEvent('GDPR_DATA_DELETION_COMPLETED', {\n        target_user_id: userId,\n        requested_by: requestedBy,\n        anonymization_id: crypto.randomUUID(),\n        records_anonymized: this.countRecords(userData)\n      });\n\n      return {\n        success: true,\n        anonymization_id: crypto.randomUUID(),\n        message: 'User data successfully anonymized'\n      };\n    } catch (error) {\n      await auditLogger.logError('GDPR_DATA_DELETION_ERROR', error, {\n        target_user_id: userId,\n        requested_by: requestedBy\n      });\n      throw error;\n    }\n  }\n\n  async anonymizeUserData(userId) {\n    const anonymizedEmail = `deleted-user-${crypto.randomBytes(8).toString('hex')}@deleted.local`;\n    const query = `\n      UPDATE users \n      SET \n        username = ?,\n        email = ?,\n        first_name = 'Deleted',\n        last_name = 'User',\n        password_hash = 'DELETED',\n        mfa_secret = NULL,\n        mfa_enabled = 0,\n        updated_at = CURRENT_TIMESTAMP\n      WHERE id = ?\n    `;\n    await pool.query(query, [`deleted-user-${userId}`, anonymizedEmail, userId]);\n  }\n\n  async anonymizeUserAssignments(userId) {\n    // Update assignments to remove PII while preserving system data\n    const query = `\n      UPDATE assignments \n      SET \n        lead_name = 'Anonymized Lead',\n        lead_identifier = CONCAT('ANON-', id),\n        manual_reason = CASE \n          WHEN manual_reason IS NOT NULL THEN 'Manual assignment (anonymized)'\n          ELSE NULL\n        END\n      WHERE sdr_id = ?\n    `;\n    await pool.query(query, [userId]);\n  }\n\n  // Check for data retention compliance\n  async auditDataRetention() {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - this.dataRetentionPeriod);\n\n    try {\n      // Find users whose data should be reviewed for retention\n      const query = `\n        SELECT id, username, email, created_at, updated_at\n        FROM users \n        WHERE updated_at < ? \n        AND username NOT LIKE 'deleted-user-%'\n        ORDER BY updated_at ASC\n      `;\n      \n      const result = await pool.query(query, [cutoffDate.toISOString()]);\n      \n      await auditLogger.logSystemEvent('DATA_RETENTION_AUDIT', {\n        cutoff_date: cutoffDate.toISOString(),\n        users_for_review: result.rows.length,\n        retention_period_days: this.dataRetentionPeriod\n      });\n\n      return {\n        cutoffDate,\n        usersForReview: result.rows,\n        retentionPeriodDays: this.dataRetentionPeriod\n      };\n    } catch (error) {\n      await auditLogger.logError('DATA_RETENTION_AUDIT_ERROR', error);\n      throw error;\n    }\n  }\n\n  // Generate privacy report\n  async generatePrivacyReport() {\n    try {\n      const totalUsers = await this.getTotalUsers();\n      const anonymizedUsers = await this.getAnonymizedUsers();\n      const recentExports = await this.getRecentDataExports();\n      const retentionAudit = await this.auditDataRetention();\n\n      const report = {\n        generated_at: new Date().toISOString(),\n        user_statistics: {\n          total_users: totalUsers,\n          active_users: totalUsers - anonymizedUsers,\n          anonymized_users: anonymizedUsers\n        },\n        gdpr_activities: {\n          recent_data_exports: recentExports,\n          data_retention_review: retentionAudit\n        },\n        compliance_status: {\n          data_retention_policy: `${this.dataRetentionPeriod} days`,\n          encryption_enabled: process.env.DB_ENCRYPTION_ENABLED === 'true',\n          audit_logging_enabled: true\n        }\n      };\n\n      await auditLogger.logSystemEvent('PRIVACY_REPORT_GENERATED', {\n        report_id: crypto.randomUUID(),\n        total_users: totalUsers,\n        anonymized_users: anonymizedUsers\n      });\n\n      return report;\n    } catch (error) {\n      await auditLogger.logError('PRIVACY_REPORT_ERROR', error);\n      throw error;\n    }\n  }\n\n  async getTotalUsers() {\n    const result = await pool.query('SELECT COUNT(*) as count FROM users');\n    return result.rows[0].count;\n  }\n\n  async getAnonymizedUsers() {\n    const result = await pool.query(\n      \"SELECT COUNT(*) as count FROM users WHERE username LIKE 'deleted-user-%'\"\n    );\n    return result.rows[0].count;\n  }\n\n  async getRecentDataExports() {\n    // This would query audit logs for recent export activities\n    // Implementation depends on your audit log structure\n    return [];\n  }\n\n  countRecords(data) {\n    let count = 0;\n    for (const key in data) {\n      if (Array.isArray(data[key])) {\n        count += data[key].length;\n      } else if (data[key] && typeof data[key] === 'object') {\n        count += 1;\n      }\n    }\n    return count;\n  }\n}\n\nconst gdprManager = new GDPRManager();\n\nmodule.exports = {\n  exportUserData: (userId, requestedBy) => gdprManager.exportUserData(userId, requestedBy),\n  deleteUserData: (userId, requestedBy, reason) => gdprManager.deleteUserData(userId, requestedBy, reason),\n  auditDataRetention: () => gdprManager.auditDataRetention(),\n  generatePrivacyReport: () => gdprManager.generatePrivacyReport(),\n  GDPRManager\n};