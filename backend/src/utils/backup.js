const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

class BackupManager {
  constructor() {\n    this.backupDir = process.env.BACKUP_DIR || path.join(__dirname, '../../backups');\n    this.encryptionKey = process.env.BACKUP_ENCRYPTION_KEY || crypto.randomBytes(32).toString('hex');\n    this.maxBackups = parseInt(process.env.MAX_BACKUPS) || 30;\n  }\n\n  async ensureBackupDir() {\n    try {\n      await fs.access(this.backupDir);\n    } catch {\n      await fs.mkdir(this.backupDir, { recursive: true });\n    }\n  }\n\n  async createDatabaseBackup() {\n    await this.ensureBackupDir();\n    \n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const backupName = `database-backup-${timestamp}.sqlite`;\n    const backupPath = path.join(this.backupDir, backupName);\n    const encryptedPath = `${backupPath}.enc`;\n    \n    try {\n      // Copy database file\n      const dbPath = process.env.DATABASE_URL || path.join(__dirname, '../../database.sqlite');\n      await fs.copyFile(dbPath, backupPath);\n      \n      // Encrypt backup\n      await this.encryptFile(backupPath, encryptedPath);\n      \n      // Remove unencrypted backup\n      await fs.unlink(backupPath);\n      \n      // Clean up old backups\n      await this.cleanupOldBackups();\n      \n      return {\n        success: true,\n        backupFile: encryptedPath,\n        timestamp,\n        size: (await fs.stat(encryptedPath)).size\n      };\n    } catch (error) {\n      console.error('Database backup failed:', error);\n      throw new Error(`Backup failed: ${error.message}`);\n    }\n  }\n\n  async encryptFile(inputPath, outputPath) {\n    return new Promise((resolve, reject) => {\n      const algorithm = 'aes-256-gcm';\n      const iv = crypto.randomBytes(16);\n      const cipher = crypto.createCipher(algorithm, this.encryptionKey);\n      \n      const input = require('fs').createReadStream(inputPath);\n      const output = require('fs').createWriteStream(outputPath);\n      \n      // Write IV to the beginning of encrypted file\n      output.write(iv);\n      \n      input.pipe(cipher).pipe(output);\n      \n      output.on('close', () => {\n        // Append auth tag\n        const tag = cipher.getAuthTag();\n        require('fs').appendFileSync(outputPath, tag);\n        resolve();\n      });\n      \n      output.on('error', reject);\n    });\n  }\n\n  async decryptFile(inputPath, outputPath) {\n    return new Promise((resolve, reject) => {\n      const algorithm = 'aes-256-gcm';\n      const input = require('fs').createReadStream(inputPath);\n      const output = require('fs').createWriteStream(outputPath);\n      \n      // Read IV and auth tag\n      const data = require('fs').readFileSync(inputPath);\n      const iv = data.slice(0, 16);\n      const tag = data.slice(-16);\n      const encryptedData = data.slice(16, -16);\n      \n      const decipher = crypto.createDecipher(algorithm, this.encryptionKey);\n      decipher.setAuthTag(tag);\n      \n      try {\n        const decrypted = decipher.update(encryptedData) + decipher.final();\n        require('fs').writeFileSync(outputPath, decrypted);\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  async restoreDatabase(backupPath) {\n    const tempPath = path.join(this.backupDir, 'temp-restore.sqlite');\n    \n    try {\n      // Decrypt backup\n      await this.decryptFile(backupPath, tempPath);\n      \n      // Verify backup integrity\n      await this.verifyBackup(tempPath);\n      \n      // Replace current database\n      const dbPath = process.env.DATABASE_URL || path.join(__dirname, '../../database.sqlite');\n      await fs.copyFile(tempPath, dbPath);\n      \n      // Clean up temp file\n      await fs.unlink(tempPath);\n      \n      return {\n        success: true,\n        message: 'Database restored successfully'\n      };\n    } catch (error) {\n      // Clean up temp file if it exists\n      try {\n        await fs.unlink(tempPath);\n      } catch {}\n      \n      throw new Error(`Restore failed: ${error.message}`);\n    }\n  }\n\n  async verifyBackup(backupPath) {\n    try {\n      // Basic SQLite integrity check\n      await execAsync(`sqlite3 \"${backupPath}\" \"PRAGMA integrity_check;\"`);\n      return true;\n    } catch (error) {\n      throw new Error('Backup file is corrupted or invalid');\n    }\n  }\n\n  async listBackups() {\n    await this.ensureBackupDir();\n    \n    const files = await fs.readdir(this.backupDir);\n    const backups = [];\n    \n    for (const file of files) {\n      if (file.startsWith('database-backup-') && file.endsWith('.enc')) {\n        const filePath = path.join(this.backupDir, file);\n        const stats = await fs.stat(filePath);\n        \n        backups.push({\n          filename: file,\n          path: filePath,\n          size: stats.size,\n          created: stats.birthtime,\n          modified: stats.mtime\n        });\n      }\n    }\n    \n    return backups.sort((a, b) => b.created - a.created);\n  }\n\n  async cleanupOldBackups() {\n    const backups = await this.listBackups();\n    \n    if (backups.length > this.maxBackups) {\n      const toDelete = backups.slice(this.maxBackups);\n      \n      for (const backup of toDelete) {\n        try {\n          await fs.unlink(backup.path);\n          console.log(`Deleted old backup: ${backup.filename}`);\n        } catch (error) {\n          console.error(`Failed to delete backup ${backup.filename}:`, error);\n        }\n      }\n    }\n  }\n\n  async scheduleAutomaticBackups() {\n    const interval = process.env.BACKUP_INTERVAL_HOURS || 24;\n    const intervalMs = interval * 60 * 60 * 1000;\n    \n    console.log(`Scheduling automatic backups every ${interval} hours`);\n    \n    setInterval(async () => {\n      try {\n        console.log('Starting scheduled database backup...');\n        const result = await this.createDatabaseBackup();\n        console.log('Scheduled backup completed:', result.backupFile);\n      } catch (error) {\n        console.error('Scheduled backup failed:', error);\n      }\n    }, intervalMs);\n    \n    // Create initial backup\n    setTimeout(async () => {\n      try {\n        await this.createDatabaseBackup();\n        console.log('Initial backup completed');\n      } catch (error) {\n        console.error('Initial backup failed:', error);\n      }\n    }, 5000); // Wait 5 seconds after startup\n  }\n}\n\nconst backupManager = new BackupManager();\n\nmodule.exports = {\n  createBackup: () => backupManager.createDatabaseBackup(),\n  restoreBackup: (backupPath) => backupManager.restoreDatabase(backupPath),\n  listBackups: () => backupManager.listBackups(),\n  scheduleBackups: () => backupManager.scheduleAutomaticBackups(),\n  BackupManager\n};