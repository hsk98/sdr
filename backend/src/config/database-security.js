const crypto = require('crypto');\nconst fs = require('fs');\nconst path = require('path');\n\nclass DatabaseSecurity {\n  constructor() {\n    this.encryptionKey = this.getEncryptionKey();\n    this.connectionConfig = this.getSecureConnectionConfig();\n  }\n\n  getEncryptionKey() {\n    const keyPath = process.env.DB_ENCRYPTION_KEY_PATH;\n    \n    if (keyPath && fs.existsSync(keyPath)) {\n      return fs.readFileSync(keyPath, 'utf8').trim();\n    }\n    \n    const envKey = process.env.DB_ENCRYPTION_KEY;\n    if (envKey) {\n      return envKey;\n    }\n    \n    // Generate and store a new key (development only)\n    if (process.env.NODE_ENV !== 'production') {\n      const newKey = crypto.randomBytes(32).toString('hex');\n      console.warn('⚠️  Generated new database encryption key. In production, use DB_ENCRYPTION_KEY_PATH or DB_ENCRYPTION_KEY.');\n      return newKey;\n    }\n    \n    throw new Error('Database encryption key not configured. Set DB_ENCRYPTION_KEY_PATH or DB_ENCRYPTION_KEY.');\n  }\n\n  getSecureConnectionConfig() {\n    const config = {\n      // SQLite-specific security settings\n      pragmas: {\n        // Enable foreign key constraints\n        foreign_keys: 'ON',\n        \n        // Use WAL mode for better concurrency and crash recovery\n        journal_mode: 'WAL',\n        \n        // Enable secure deletion\n        secure_delete: 'ON',\n        \n        // Set reasonable timeout for busy database\n        busy_timeout: '30000',\n        \n        // Optimize for security over performance\n        synchronous: 'FULL',\n        \n        // Enable automatic index creation\n        automatic_index: 'ON'\n      },\n      \n      // Connection pool settings\n      pool: {\n        min: 1,\n        max: 10,\n        acquireTimeoutMillis: 30000,\n        createTimeoutMillis: 30000,\n        destroyTimeoutMillis: 5000,\n        idleTimeoutMillis: 30000,\n        reapIntervalMillis: 1000,\n        createRetryIntervalMillis: 200\n      },\n      \n      // Security settings\n      security: {\n        // Encrypt database file (if using encrypted SQLite)\n        encrypted: process.env.DB_ENCRYPTION_ENABLED === 'true',\n        \n        // File permissions for database\n        fileMode: 0o600, // Read/write for owner only\n        \n        // Backup encryption\n        backupEncryption: true,\n        \n        // Connection timeout\n        connectionTimeout: 30000\n      }\n    };\n    \n    return config;\n  }\n\n  // Apply security settings to database connection\n  async secureConnection(db) {\n    try {\n      // Apply PRAGMA settings\n      for (const [pragma, value] of Object.entries(this.connectionConfig.pragmas)) {\n        await db.exec(`PRAGMA ${pragma} = ${value}`);\n      }\n      \n      // Set connection timeout\n      await db.exec(`PRAGMA busy_timeout = ${this.connectionConfig.security.connectionTimeout}`);\n      \n      console.log('✅ Database security settings applied');\n      return true;\n    } catch (error) {\n      console.error('❌ Failed to apply database security settings:', error);\n      throw error;\n    }\n  }\n\n  // Encrypt sensitive data before storing\n  encryptSensitiveData(data, field) {\n    if (!data || !data[field]) return data;\n    \n    try {\n      const algorithm = 'aes-256-gcm';\n      const iv = crypto.randomBytes(16);\n      const cipher = crypto.createCipher(algorithm, this.encryptionKey);\n      \n      let encrypted = cipher.update(data[field], 'utf8', 'hex');\n      encrypted += cipher.final('hex');\n      \n      const authTag = cipher.getAuthTag();\n      \n      // Store as JSON with IV and auth tag\n      data[field] = JSON.stringify({\n        encrypted,\n        iv: iv.toString('hex'),\n        tag: authTag.toString('hex'),\n        algorithm\n      });\n      \n      return data;\n    } catch (error) {\n      console.error('Encryption failed:', error);\n      throw new Error('Failed to encrypt sensitive data');\n    }\n  }\n\n  // Decrypt sensitive data after retrieval\n  decryptSensitiveData(data, field) {\n    if (!data || !data[field]) return data;\n    \n    try {\n      // Check if data is already encrypted\n      if (typeof data[field] === 'string' && data[field].startsWith('{')) {\n        const encryptedData = JSON.parse(data[field]);\n        const { encrypted, iv, tag, algorithm } = encryptedData;\n        \n        const decipher = crypto.createDecipher(algorithm, this.encryptionKey);\n        decipher.setAuthTag(Buffer.from(tag, 'hex'));\n        \n        let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n        decrypted += decipher.final('utf8');\n        \n        data[field] = decrypted;\n      }\n      \n      return data;\n    } catch (error) {\n      console.error('Decryption failed:', error);\n      // Return original data if decryption fails (might not be encrypted)\n      return data;\n    }\n  }\n\n  // Hash sensitive data for searching/indexing\n  hashForIndex(value) {\n    return crypto.createHash('sha256').update(value + this.encryptionKey).digest('hex');\n  }\n\n  // Validate database file permissions\n  async validateDatabaseSecurity(dbPath) {\n    try {\n      const stats = fs.statSync(dbPath);\n      const mode = stats.mode & parseInt('777', 8);\n      \n      // Check if file permissions are secure (600 or 640)\n      if (mode > parseInt('640', 8)) {\n        console.warn(`⚠️  Database file permissions (${mode.toString(8)}) may be too permissive. Recommended: 600`);\n        \n        // Attempt to fix permissions in development\n        if (process.env.NODE_ENV !== 'production') {\n          fs.chmodSync(dbPath, 0o600);\n          console.log('✅ Fixed database file permissions');\n        }\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Failed to validate database security:', error);\n      return false;\n    }\n  }\n\n  // Create secure backup with encryption\n  async createSecureBackup(sourcePath, backupPath) {\n    try {\n      const algorithm = 'aes-256-gcm';\n      const iv = crypto.randomBytes(16);\n      const cipher = crypto.createCipher(algorithm, this.encryptionKey);\n      \n      const input = fs.createReadStream(sourcePath);\n      const output = fs.createWriteStream(backupPath);\n      \n      // Write IV to the beginning of the file\n      output.write(iv);\n      \n      return new Promise((resolve, reject) => {\n        input.pipe(cipher).pipe(output);\n        \n        output.on('close', () => {\n          // Append auth tag\n          const tag = cipher.getAuthTag();\n          fs.appendFileSync(backupPath, tag);\n          \n          // Set secure permissions\n          fs.chmodSync(backupPath, 0o600);\n          \n          resolve({\n            success: true,\n            backupPath,\n            encrypted: true,\n            size: fs.statSync(backupPath).size\n          });\n        });\n        \n        output.on('error', reject);\n        input.on('error', reject);\n      });\n    } catch (error) {\n      console.error('Secure backup failed:', error);\n      throw error;\n    }\n  }\n\n  // Performance monitoring for security\n  monitorDatabasePerformance() {\n    const metrics = {\n      connectionPool: {\n        active: 0,\n        idle: 0,\n        waiting: 0\n      },\n      queries: {\n        total: 0,\n        slow: 0,\n        failed: 0\n      },\n      security: {\n        encryptionOperations: 0,\n        decryptionOperations: 0,\n        hashOperations: 0\n      }\n    };\n    \n    return metrics;\n  }\n}\n\nconst dbSecurity = new DatabaseSecurity();\n\nmodule.exports = {\n  secureConnection: (db) => dbSecurity.secureConnection(db),\n  encryptSensitiveData: (data, field) => dbSecurity.encryptSensitiveData(data, field),\n  decryptSensitiveData: (data, field) => dbSecurity.decryptSensitiveData(data, field),\n  hashForIndex: (value) => dbSecurity.hashForIndex(value),\n  validateDatabaseSecurity: (dbPath) => dbSecurity.validateDatabaseSecurity(dbPath),\n  createSecureBackup: (sourcePath, backupPath) => dbSecurity.createSecureBackup(sourcePath, backupPath),\n  monitorDatabasePerformance: () => dbSecurity.monitorDatabasePerformance(),\n  getConnectionConfig: () => dbSecurity.connectionConfig,\n  DatabaseSecurity\n};